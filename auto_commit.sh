#!/bin/bash
# auto_commit.sh

# Check for required tool: jq
if ! command -v jq &> /dev/null; then
  echo "Error: jq is not installed. Please install it with 'brew install jq'."
  exit 1
fi

# Ensure your OpenAI API key is set in the environment
if [ -z "$OPENAI_API_KEY" ]; then
  echo "Error: OPENAI_API_KEY is not set."
  exit 1
fi

# Get a list of files in the repository (excluding the .git directory)
FILE_LIST=$(find . -type f ! -path "./.git/*" | sed 's/^\.\///' | tr '\n' ',')

# Construct the prompt for OpenAI.
read -r -d '' PROMPT << EOM
You are a creative developer who continuously evolves a project.
The current codebase includes the following files:
$FILE_LIST

Based on the entire codebase and all previous improvements, propose one creative addition or improvement that builds on what was created before.
Return only a valid JSON object with exactly three keys:
  "file_name": the name of a new file to add or an existing file to modify (e.g., "new_feature.py" or "README.md"),
  "file_content": the complete new content for that file (if modifying, include the entire updated content),
  "commit_message": a succinct commit message describing the change.
Do not include any extra text, markdown formatting, headers, or explanations.
EOM

# Use jq to build a valid JSON payload for the API call, using your desired model (e.g., "gpt-4o")
JSON_PAYLOAD=$(jq -n \
  --arg model "gpt-4o" \
  --arg content "$PROMPT" \
  --argjson temperature 0.7 \
  --argjson max_tokens 800 \
  '{
    "model": $model,
    "messages": [{"role": "user", "content": $content}],
    "temperature": $temperature,
    "max_tokens": $max_tokens
  }'
)

# (Optional) Debug: Uncomment the next line to inspect the JSON payload
# echo "$JSON_PAYLOAD" | jq .

# Call the OpenAI Chat API with the JSON payload
RESPONSE=$(curl https://api.openai.com/v1/chat/completions \
  -s \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $OPENAI_API_KEY" \
  -d "$JSON_PAYLOAD"
)

# (Optional) Debug: Uncomment the next line to inspect the raw API response
# echo "$RESPONSE" | jq .

# Extract the message content from the API response
RAW_CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')

# Remove Markdown code fences (e.g., "```json" and "```")
CLEANED_CONTENT=$(echo "$RAW_CONTENT" | sed -E 's/```json//g; s/```//g')

# Parse the cleaned JSON content using jq without using fromjson
FILE_NAME=$(echo "$CLEANED_CONTENT" | jq -r '.file_name')
FILE_CONTENT=$(echo "$CLEANED_CONTENT" | jq -r '.file_content')
COMMIT_MESSAGE=$(echo "$CLEANED_CONTENT" | jq -r '.commit_message')

# Basic error handling if parsing fails
if [ "$FILE_NAME" == "null" ] || [ -z "$FILE_NAME" ]; then
  echo "Error: Failed to extract file_name from the API response. Full cleaned response:"
  echo "$CLEANED_CONTENT" | jq .
  exit 1
fi

# Create or update the file with the content generated by the model
echo "$FILE_CONTENT" > "$FILE_NAME"

# Stage, commit, and push the new or updated file
git add "$FILE_NAME"
git commit -m "$COMMIT_MESSAGE"
git push origin main
